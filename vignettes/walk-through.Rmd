---
title: "covidReff model walk-through"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
```

This model 
Simulate Covid transmission in a population based on effective reproduction and vaccination rate inputs.

At its core, this model uses individual agents -- one for each of the resident of the Australian population -- to simulate the spread of Covid within a partially vaccinated population.

The simulation process is described below.

# Simulation process

## Iteration 0: starting conditions

The most recent Australian population estimates by age are pulled from ABS _National, state and territory population_.^[Table 59 of [ABS Cat. 3101.0](https://www.abs.gov.au/statistics/people/population/national-state-and-territory-population/latest-release), accessed using the [`readabs` package](https://github.com/MattCowgill/readabs).]
The population is then 'uncounted' by age so that there is one row of data per person, with one variable showing their single-digit age.

This population is then scaled down (or up) proportionally by age to the `n_population` variable to create an `aus` dataset that contains `n_population` rows and `1` variable showing each individual's age.

A proportion of the population is then **fully vaccinated** (having already received two doses) according to the conditions set out in `vaccination_levels`. A person's age is matched with their likelihood of already being vaccinated, and if a random draw is below that level, the person is vaccinated.^[The process `runif(.N) <= .get_vaccination_level(...)` is run over the entire population.]

For each vaccinated person, a **vaccine type** is generated using their age and the parameters set out in `over60_az_share` and `under60_az_share`. For example, if `over60_az_share = 0.8`, then 80 per cent of the already-vaccinated population over the age of 60 would have an AstraZeneca (AZ) vaccine, and 40 per cent would have a Pfizer (Pf) vaccine.^[Only the AstraZeneca and Pfizer vaccines are explored in this simulation because of both data availability against the Delta strain and Australia's near-future vaccine supply. These parameters will evolve as necessary.]

For each fully-vaccinated person by vaccine type, the implied number of people with only a **first dose** of that vaccine is calculated. This number is based on time between first and second dose for each vaccine (`r az_1_second_dose_wait_days` days for AZ, `r pf_1_second_dose_wait_days` days for Pf) and the recent growth rates by vaccine type (i.e. how many people in the past X days would have had their first shot; see **Vaccine growth rate** below). For each person starting the simulation with only a first dose of a vaccine, the days since their first dose is also generated based on their vaccine type.

A number of new infections are then introduced. The `n_start_infected` parameter  causes people to be infected. Some of the initially infected are vaccinated, and some are not (reflective of the starting vaccination level).

Finishing the initial population construction gives a dataset with `n_population` rows and a number of variables indicating age, vaccination status and type, and days since first dose. Some of this population are infected, and (potentially) spread the virus to others in the next iteration.


# Iteration 1: first round of subsequent infections 

The first iteration is on 'day' `iteration * serial_interval` (e.g. `1 * 5` if the serial interval is 5 days), and starts with the `aus` dataset created in iteration zero described above.

## Vaccinate more people

The first step is updating people's vaccines:

- People with a first dose get their time progressed (`days_since_first_dose := days_since_first_dose + serial_interval`).
- People with a first dose whose days are above their second-dose waiting period are converted to 'fully vaccinated'. 
- The number of newly first-dose vaccinated people is then calculated with a logistic curve with a growth parameter of `vaccination_growth_steepness`.^[`vaccination_growth_steepness` defines how quickly additional people are vaccinated after opening, defaulting to 0.01. This is the growth parameter (\code{c}) in the logistic curve \code{M / (1 + ((M - n0) / n0) * exp(-c*t))}, where \code{n0} is the starting vaccination level defined by  \code{vaccination_levels}.]
- Each newly vaccinated person is given a type of vaccine and the characteristics that come with it -- either a mix of AZ and Pf, or just Pf (`only_pfizer_after_opening = TRUE`).

## Infect more people

The number of previous 'newly infected' (in the last iteration) people along with the `R` parameter are used to work out the number of people that _would be infected without vaccines_. The number of previously newly infected is split by vaccinated and unvaccinated because vaccinated infectious people are less likely to _transmit_ the virus (described in the `vac_transmission_rate` parameter). 
The number of 'maybe infected' (i.e. the number of infected if it weren't for vaccine protection) is generated with:

```{r eval=FALSE}
n_maybe_infected <- 
  n_infected_and_vaccinated   * R * vac_transmission_rate +
  n_infected_and_unvaccinated * R
```


A number `n_maybe_infected` of the `aus` population are then 'exposed' to these infections. Whether they become infected depends on:

- if a contact has already been infected, they are not infected; otherwise
- if a contact has one or two dose vaccine, they are infected if the random number drawn for them is more than their vaccine protection;^[For example, if a person has two doses of the Pfizer vaccine, they have `r pf_2_poi` protection. This process would randomly generate a number between `0` and `1`, and if it was **less  than** than `r pf_2_poi`, the person would be protected. If the number was greater than their protection level, the person would become infected.] otherwise
- if a contact is not already infected or vaccinated, they become infected.

Those who are newly infected in the process above are labelled as `newly_infected = TRUE`. 

## Externally introduced cases

Added to the `newly_infected` group above are the daily (scaled by iterations) Covid cases from external arrivals, determined by `n_daily_introductions`. Each iteration, a random sample of `n_daily_introductions * serial_interval` vaccinated people are infected. 

## Deaths

Whether each person in the newly infected group (eventually) **dies** is then determined using an age-wise infection fatality ratio developed by [Levin et al. (2020)](https://pubmed.ncbi.nlm.nih.gov/33289900/). 

The `covid_age_death_prob` function also includes a 20% reduction in the death rate to reflect improvements in treatment for COVID patients since early-mid 2020, and implement a fatality rate cap of 28%.^[Both figures used after informal consultation with one of the authors of the paper.]

```{r, eval=FALSE}
covid_age_death_prob <- function(.age,
                                 .vaccine = "none",
                                 .dose = 0,
                                 .treatment_improvement = 0.2,
                                 .max_death_rate = 0.28 # 90-year-old death rate as per Gideon
) {

  age <- as.numeric(.age)

  # get death rate from Levin at al https://pubmed.ncbi.nlm.nih.gov/33289900/
  ifr <- 10^(-3.27 + 0.0524 * age) / 100

  # cap base death rate (on advice from MK)
  ifr <- if_else(ifr > .max_death_rate, .max_death_rate, ifr)

  # add treatment improvement (on advice from MK)
  ifr <- ifr * (1 - .treatment_improvement)

  # add vaccine protection
  .vac_death_reduction <- fcase(
      .vaccine == "pf" & .dose == 1L, pf_1_pod,
      .vaccine == "pf" & .dose == 2L, pf_2_pod,
      .vaccine == "az" & .dose == 1L, az_1_pod,
      .vaccine == "az" & .dose == 2L, az_2_pod,
      .vaccine == "none", 0
    )

  ifr <- ifr * (1 - .vac_death_reduction)

  return(ifr)

}
```


## Summary

When an iteration of vaccinations, infections and deaths is finished, the following results are summarised and stored (see `?simulate_covid`)

```{r, eval=FALSE}
tibble(
  iteration = t,
  new_maybe_infected_i = n_maybe_infected,
  new_cases_i = new_cases,
  new_local_cases_i = new_local_cases,
  new_os_cases_i = new_os_cases,
  new_cases_vaccinated2_i = new_cases_vac,
  new_dead_i = new_dead,
  new_dead_vaccinated2_i = new_dead_vac,
  new_vaccinated_i = new_vaccinated,
  total_vaccinated1_i = total_vaccinated1,
  total_vaccinated2_i = total_vaccinated2,
  total_pf_i = total_pf,
  total_az_i = total_az
)
```

The summary table is then appended to previous iterations of results, and the `aus` dataset moves onto the next iteration.

# Iterations 2-N

The process described in 1 repeats for each iteration that is requested.

As time (iterations) goes on, there are two major influencers of the: the (new) proportion of the population who are vaccinated, and the proportion who become immune through infection or death. 
